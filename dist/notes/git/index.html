<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="generator" content="Astro v2.6.6">

<!-- Canonical URL -->
<link rel="canonical" href="https://example.com/notes/git/">

<!-- Primary Meta Tags -->
<title>GIT</title>
<meta name="title" content="GIT">
<meta name="description" content="Lorem ipsum dolor sit amet">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://example.com/notes/git/">
<meta property="og:title" content="GIT">
<meta property="og:description" content="Lorem ipsum dolor sit amet">
<meta property="og:image" content="https://example.com/placeholder-social.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://example.com/notes/git/">
<meta property="twitter:title" content="GIT">
<meta property="twitter:description" content="Lorem ipsum dolor sit amet">
<meta property="twitter:image" content="https://example.com/placeholder-social.jpg">
  <link rel="stylesheet" href="/_astro/about.d9cdec7b.css" />
<link rel="stylesheet" href="/_astro/about.99ca717b.css" />
<link rel="stylesheet" href="/_astro/HeaderLink.astro_astro_type_style_index_0_lang.06f8633c.css" /></head>

  <body class="flex flex-col">
    <header class="px-4 my-16 mx-auto max-w-3xl w-full flex justify-between">
  <nav class="flex gap-3">
    <a href="/" class="astro-EIMMU3LG">
	Inicio
</a> /
    <a href="/notes" class="astro-EIMMU3LG">
	Notas
</a>
    <!-- <HeaderLink href="/about">About</HeaderLink> -->
  </nav>
  <div class="flex gap-2">
    <a href="https://github.com/juanpabotero" target="_blank" rel="noopener noreferrer">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33c.85 0 1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2Z"></path>
      </svg>
    </a>
    <a href="https://www.linkedin.com/in/juanpabotero/" target="_blank" rel="noopener noreferrer">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77Z"></path>
      </svg>
    </a>
  </div>
</header>
    <main class="px-4 max-w-3xl mx-auto w-full">
      <article class="post">
        <!-- {heroImage && <img width={720} height={360} src={heroImage} alt="" />} -->
        <!-- <h1 class="title">{title}</h1> -->
        <!-- <FormattedDate date={pubDate} /> -->
        <!-- {
          updatedDate && (
            <div class="last-updated-on">
              Last updated on <FormattedDate date={updatedDate} />
            </div>
          )
        } -->
        
  
  <h1 id="git">GIT</h1>
<h1 id="teoria">Teoria</h1>
<h2 id="estados-en-git">Estados en git:</h2>
<ul>
<li><strong>modified</strong>: el archivo contiene cambios pero no han sido
marcados para ser confirmados, se encuentra en el directorio
de trabajo.</li>
<li><strong>staged</strong>: el archivo ha sido marcado como preparado para ser
confirmado en el repositorio local, se encuentra en el area
de preparacion (stage area).
Esta accion recibe el nombre de add.</li>
<li><strong>committed</strong>: el archivo ha sido guardado en el repositorio local.
Esta accion recibe el nombre de commit.</li>
</ul>
<h2 id="head">HEAD</h2>
<p>Es el puntero que hace referencia al punto actual del historial de
cambios del repositorio, normalmente es el ultimo commit</p>
<h2 id="archivos-y-carpetas-que-se-deberian-ignorar">Archivos y carpetas que se deberian ignorar:</h2>
<ul>
<li>archivos con credenciales o llaves API (deberian inyectarse por
variable de entorno)</li>
<li>carpetas de configuracion del editor (/.vscode)</li>
<li>archivos de registro (log files)</li>
<li>archivos de sistema como .DS_Store</li>
<li>carpetas generadas con archivos estaticos compilaciones como
/dist ó /build</li>
<li>dependencias que pueden ser descargadas (/node_modules)</li>
<li>coverage del testing (/coverage)</li>
</ul>
<h1 id="general">General</h1>
<ul>
<li>
<p><code>git --version</code><br>
ver version de git</p>
</li>
<li>
<p><code>git init</code><br>
inicializar el repositorio git</p>
</li>
<li>
<p><code>git config --global user.name "nombreUsuario"</code><br>
configurar el nombre del usuario de manera global</p>
</li>
<li>
<p><code>git config --global user.email "emailUsuario"</code><br>
configurar el email del usuario de manera global</p>
</li>
<li>
<p><code>git config user.name "nombreUsuario"</code><br>
configurar el nombre del usuario en un repositorio en concreto
estando en la carpeta del proyecto</p>
</li>
<li>
<p><code>git config user.email "emailUsuario"</code><br>
configurar el email del usuario en un repositorio en concreto
estando en la carpeta del proyecto</p>
</li>
<li>
<p><code>git config --global core.editor "nombreEditor"</code><br>
configurar el editor de texto por defecto.
Para VSCode se usa “code”</p>
</li>
<li>
<p><code>git config --list</code><br>
mirar la configuracion del git.<br>
si hay algun valor repetido, el ultimo valor prevalece.<br>
puedo usar las banderas —global, —local, —system para ver solo
la configuracion que me interese.</p>
</li>
<li>
<p><code>git status</code><br>
ver el estado del repositorio</p>
</li>
<li>
<p><code>git help comando</code><br>
ayuda con el comando nombrado</p>
</li>
<li>
<p><code>git clone repoOriginal repoClon</code><br>
clonar un repositorio, debe tener otro nombre</p>
</li>
<li>
<p><code>rm -rf .git </code><br>
para remover git del proyecto</p>
</li>
<li>
<p><code>rm -rf repositorio</code><br>
eliminar repositorio</p>
</li>
<li>
<p><code>git rm archivo</code><br>
borrar archivo del repositorio y del directorio de trabajo</p>
</li>
<li>
<p><code>git rm --cached archivo</code><br>
borrar archivo del repositorio pero no del directorio de trabajo</p>
</li>
<li>
<p><code>touch .gitignore</code><br>
crear el archivo que va a contener los archivos o carpetas que
queremos que git ignore</p>
</li>
<li>
<p><code>--dry-run</code><br>
al final de los comandos significa que quiero saber que resultado
tendria una accion sin realizarla</p>
</li>
</ul>
<h1 id="commits">Commits</h1>
<ul>
<li>
<p><code>git add archivo</code><br>
agrega el archivo o directorio al area de preparacion</p>
</li>
<li>
<p><code>git add .</code><br>
agrega todos los archivos al area de preparacion</p>
</li>
<li>
<p><code>git reset archivo</code><br>
quitar el archivo del area de preparacion.<br>
tambien se puede usar:<br>
<code>git rm --cached archivo</code></p>
</li>
<li>
<p><code>git commit -m "mensaje" </code><br>
hacer commit con un mensaje</p>
</li>
<li>
<p><code>git commit -am "mensaje" </code><br>
hacer commit directamente con un mensaje sin usar git add</p>
</li>
<li>
<p><code>git commit --amend -m "mensaje del commit"</code><br>
modificar el mensaje del ultimo commit.<br>
Si ademas quiero agregar nuevos archivos al ultimo commit, debo ejecutar
antes git add</p>
</li>
<li>
<p><code>git log</code><br>
me muestra todos los commits hechos</p>
</li>
<li>
<p><code>git log --grep=palabraClave</code><br>
buscar commit por palabra clave del commit</p>
</li>
<li>
<p><code>git log -S 'palabra'</code><br>
buscar commit por una palabra que esta dentro de un fichero
que contiene el commit</p>
</li>
<li>
<p><code>git restore archivo</code><br>
descarta los cambios hechos en el archivo y lo restaura como estaba
en el ultimo commit.<br>
tambien se puede usar checkout pero ya no es tan recomendable:<br>
<code>git checkout archivo</code></p>
</li>
<li>
<p><code>git restore .</code><br>
descarta los cambios de todos los archivos y los restaura como estaban
en el ultimo commit.<br>
tambien se puede usar checkout pero ya no es tan recomendable:<br>
<code>git checkout .</code></p>
</li>
<li>
<p><code>git checkout -- .</code><br>
deshacer los cambios y volver al proyecto como lo tenia hasta el ultimo commit</p>
</li>
<li>
<p><code>git symbolic-ref HEAD</code><br>
muestra la referencia del HEAD</p>
</li>
<li>
<p><code>git rev-parse HEAD</code><br>
muestra el valor del HEAD</p>
</li>
<li>
<p><code>git reset HEAD~1</code><br>
borra el ultimo commit pero deja los cambios disponibles en los
archivos y mueve HEAD 1 paso desde el ultimo commit (vuelve a
la version inmediatamente anterior a la que estamos ahora).
tambien se puede usar con el comando:<br>
<code>git reset --soft HEAD~1 (midu)</code></p>
</li>
<li>
<p><code>git reset --hard HEAD~1</code><br>
igual que el de arriba pero los cambios no estan disponibles</p>
</li>
<li>
<p><code>git checkout hashCommit</code><br>
ir a ese commit</p>
</li>
<li>
<p><code>git cherry-pick hashCommit</code><br>
aplicar el commit indicado, puede estar en otra rama.<br>
para poder usar este comando el directorio de trabajo debe estar limpio de
archivos modificados</p>
</li>
<li>
<p><code>git cherry-pick hashCommit -e</code><br>
aplicar el commit indicado y cambiar el mensaje del commit</p>
</li>
</ul>
<h1 id="ramas">Ramas</h1>
<ul>
<li>
<p><code>git branch</code><br>
muestra las ramas.<br>
Un asterisco significa la rama en la que me encuentro actualmente.
igualmente puedo mostrar la rama actual con:<br>
<code>git branch --show-current</code></p>
</li>
<li>
<p><code>git branch ramaNueva</code><br>
crea una nueva rama.</p>
</li>
<li>
<p><code>git branch ramaNueva ramaOrigen</code><br>
opcional se puede poner la rama desde la cual quiero crear la nueva rama</p>
</li>
<li>
<p><code>git branch -d rama</code><br>
eliminar una rama que ya ha sido fusionada</p>
</li>
<li>
<p><code>git branch -D rama</code><br>
eliminar una rama que no ha sido fusionada</p>
</li>
<li>
<p><code>git branch -m rama nuevoNombre</code><br>
renombrar una rama</p>
</li>
<li>
<p><code>git switch rama</code><br>
moverse a esa rama.
tambien se puede usar con checkout pero ya no es recomendable
<code>git checkout rama</code></p>
</li>
<li>
<p><code>git switch -c ramaNueva </code><br>
crea una nueva rama y se mueve a ella.</p>
</li>
<li>
<p><code>git switch -c ramaNueva ramaOrigen</code><br>
opcional se puede poner la rama desde la cual quiero crear la nueva rama.<br>
tambien se puede usar con checkout pero ya no es recomendable<br>
<code>git checkout -b &#x3C;rama></code></p>
</li>
<li>
<p><code>git merge &#x3C;rama></code><br>
unir una rama a otra. Debo estar en la rama a la cual deseo traer
los cambios y pongo el nombre de la rama que contiene los cambios</p>
</li>
<li>
<p><code>git rebase &#x3C;rama></code><br>
El rebase es una forma de fusionar cambios de una rama a otra, como el merge,<br>
pero esta nos permite reordenar el historial de commits de una rama.<br>
<code>git rebase --continue</code><br>
Para seguir el rebase después de resolver conflictos.<br>
<code>git rebase --abort</code><br>
Para abortar el rebase.</p>
<p>Lo ideal seria usar merge para integrar cambios en una rama principal y<br>
usar rebase para integrar cambios en una rama de desarrollo. Dicho de<br>
otro modo: nunca usaría rebase en una rama principal, ni tampoco en una<br>
rama pública donde más personas están trabajando.</p>
</li>
<li>
<p><code>git remote prune origin --dry-run</code><br>
mira que ramas locales han dejado de estar enlazadas con el
respositorio remoto origin, es decir, me indica que ramas locales ya han
sido fusionadas en el repositorio remoto y ya no serian necesarias.<br>
si quiero ejecutar el comando, doy:
<code>git remote prune origin</code></p>
</li>
</ul>
<h1 id="repo-remoto">Repo remoto</h1>
<ul>
<li>
<p><code>git remote add aliasRepoRemoto rutaRepoRemoto</code><br>
agrega un repositorio remoto a nuestro repositorio local,
normalmente se le asigna el alias de origin para indicar que es el
repositorio remoto principal.<br>
es recomendable usar la ruta SSH (se debe haber configurado previamente
la conexion SSH)</p>
</li>
<li>
<p><code>git push -u aliasRepoRemoto rama</code><br>
subir los cambios del repositorio local al repositorio remoto en la
rama especificada.
el -u le dice a git que esta es mi configuracion por defecto,
por lo tanto, despues solo tengo q usar:
git push</p>
</li>
<li>
<p><code>git push aliasRepoRemoto rama</code><br>
subir la rama del repositorio local al repositorio remoto.
tambien se usa para enviar los cambios a una configuracion que no
esta por defecto (como el comando de arriba)</p>
</li>
<li>
<p><code>git push aliasRepoRemoto --delete rama</code><br>
eliminar una rama del repositorio remoto.</p>
</li>
<li>
<p><code>git pull aliasRepoRemoto rama</code><br>
bajar los cambios del repositorio remoto de la rama indicada al
repositorio local</p>
</li>
<li>
<p><code>git clone rutaRepoRemoto</code><br>
hacer una copia del repositorio remoto al entorno local
incluye ficheros, ramas y commits.<br>
la forma preferida de hacerlo deberia ser SSH, para esto, primero
se debe configurar la conexion SSH.<br>
Si quiero clonar el proyecto solo con el ultimo commit, ejecuto:<br>
<code>git clone rutaRepoRemoto --depth=1</code><br>
Clonaria la ultima version del repositorio pero sin todo el historial.</p>
</li>
<li>
<p><code>git remote -v</code><br>
muestra las URLs de los repositorios remotos que estan asociados con
el repositorio local</p>
</li>
<li>
<p><code>git remote set-url aliasRepoRemoto rutaRepositorioRemoto</code><br>
cambiar la ruta del repositorio remoto</p>
</li>
<li>
<p><code>git remote set-head origin main</code><br>
actualizar el puntero HEAD para que apunte a la rama main del
repositorio remoto</p>
</li>
<li>
<p><code>git remote set-head origin --auto</code><br>
se puede usar —auto al final para que apunte automaticamente a la
rama principal del repositorio remoto</p>
</li>
<li>
<p><code>git fetch --all</code><br>
baja todas las ramas que tenemos en el repositorio remoto.<br>
se debe hacer switch a esa rama para verla</p>
</li>
<li>
<p>bajar una rama remota al local y que queden enlazadas:</p>
<ul>
<li><code>git fetch repoRemoto</code>: para bajar los cambios</li>
<li><code>git switch ramaRepoRemoto</code>: crea una rama local con el mismo
nombre y a partir de la rama remota, ademas queda trackendola</li>
</ul>
</li>
<li>
<p><code>git config credential.username "userName"</code><br>
Configurar las credenciales para el proyecto</p>
</li>
</ul>
<h1 id="tags">Tags</h1>
<p><strong>Tags</strong>: normalmente se usan para hacer versionado del codigo<br>
ej, v1.2.0, v1.2.1, v1.2.2, etc</p>
<ul>
<li>
<p><code>git tag -a &#x3C;nombreTag> -m "mensaje"</code><br>
poner un tag con un mensaje</p>
</li>
<li>
<p><code>git tag -a &#x3C;nombreTag> &#x3C;hashCommit> -m "mensaje"</code><br>
poner un tag con un mensaje a un commit especifico</p>
</li>
<li>
<p><code>git tag</code><br>
mostrar los tags</p>
</li>
<li>
<p><code>git push --tags</code><br>
subir los tags al repositorio remoto.<br>
en github, para hacer un release a partir del tag, doy click en release,
click en tags, click en el tag, click en create release from tag,
pongo el titulo, descripcion (funciona como Markdown), publish release</p>
</li>
<li>
<p><code>git tag -d &#x3C;nombreTag></code><br>
eliminar tag</p>
</li>
</ul>
<h1 id="stash">Stash</h1>
<p><strong>Stash</strong> es un almacen temporal para los cambios que aun no queremos confirmar
como commit pero que tampoco queremos perder, para poder moverse a otras
ramas y demas con tranquilidad</p>
<ul>
<li>
<p><code>git stash</code><br>
guargar los archivos a los que se les hace seguimiento en el stash</p>
</li>
<li>
<p><code>git stash -u</code><br>
guardar tanto los archivos que se les hace seguimiento como los que no</p>
</li>
<li>
<p><code>git stash -m "mensaje"</code><br>
guardar los archivos a los que se les hace seguimiento con un mensaje</p>
</li>
<li>
<p><code>git stash list</code><br>
mostrar los stashs</p>
</li>
<li>
<p><code>git stash pop</code><br>
traer y aplicar los ultimos cambios que tenemos en el almacen temporal,
ademas elimina ese ultimo stash que se trajo. El último stash es el 0.</p>
</li>
<li>
<p><code>git stash apply</code><br>
traer y aplicar los ultimos cambios que tenemos en el almacen temporal,
sin eliminar el ultimo stash que se trajo</p>
</li>
<li>
<p><code>git stash apply 2</code><br>
para traer unos cambios especificos</p>
</li>
<li>
<p><code>git stash drop &#x3C;indiceStash></code><br>
eliminar el stash indicado</p>
</li>
<li>
<p><code>git stash branch &#x3C;rama> &#x3C;indiceStash></code><br>
crear una rama a partir de los cambios del stash especificado</p>
</li>
<li>
<p><code>git stash clear</code><br>
limpiar el stash</p>
</li>
</ul>
<h1 id="errores">Errores</h1>
<ul>
<li><em>remote: Permission to ‘repositorio’ denied to ‘username’</em><br>
Si ya se tienen las credenciales configuradas, se debe cambiar el username:<br>
<code>git config credential.username "new name"</code></li>
</ul>
<h1 id="otros">Otros</h1>
<ul>
<li>
<p>si se tiene un archivo en conflicto al hacer el merge,
se debe resolver manualmente, indicando la estructura final
que deseamos y con un commit confirmamos los cambios</p>
</li>
<li>
<p><strong>Pull Request (PR)</strong>, es sugerirle al dueño del repositorio que
haga un pull de nuestro repositorio con los cambios.
merge request funcionaria de la misma manera pero con merge</p>
</li>
<li>
<p><strong>SSH</strong>: es un protocolo de comunicacion segura que permite a los usuarios
de una red conectarse a un servidor remoto. Esto permite trabajar con
repositorios remotos sin necesidad de usar usuario y contraseña cada vez
que se haga una accion.</p>
</li>
<li>
<p><strong>Fork</strong> en Github significa copiar el repositorio de alguien mas
en nuestra cuenta y evolucionar el codigo de ese repositorio sin
afectar o tener en cuenta el original</p>
</li>
<li>
<p>en el libro de aprendiendo-git en la parte de trucos con Git tengo:</p>
<ul>
<li>aplicar cambios de un commit a otro</li>
<li>detectar que commit ha introducido el bug</li>
<li>saber quien ha hecho cambios en un archivo</li>
<li>saber quien añadió una linea por primera vez</li>
<li>recuperar un archivo en concreto de otra rama o commit</li>
<li>encontrar el primer commit de un repositorio</li>
<li>saber el maximo contribuidor de un repositorio</li>
<li>saber todos los commits de un usuario en especifico</li>
<li>clonar un repositorio sin descargar todo el historico</li>
<li>vuelve a la rama previa en la que estaba trabajando</li>
<li>descargar los ficheros de un repositorio remoto sin tener que clonarlo</li>
</ul>
</li>
</ul>

      </article>
    </main>
    <div class="fixed -z-10 h-[150px] w-[150px] lg:w-[300px] lg:h-[300px] rounded-full bg-red-500 blur-[150px] md:blur-[350px] opacity-50 left-0 top-0">
    </div>
    <div class="fixed -z-10 h-[150px] w-[150px] lg:w-[300px] lg:h-[300px] rounded-full bg-yellow-500 blur-[150px] md:blur-[350px] opacity-50 right-0 bottom-0">
    </div>
    <footer class="text-center p-6 pt-8 mt-auto">
	&copy; 2023 desarrollado por <b>Juan Pablo Botero</b>.
</footer>
  </body></html>